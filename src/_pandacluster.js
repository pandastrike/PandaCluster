// Generated by CoffeeScript 1.8.0
(function() {
  var AWS, add_unit, async, build_error, build_success, build_template, customize_cluster, destroy_cluster, detect_formation, error, exec, execute, get_body, get_cluster_ip_address, get_discovery_url, get_formation_status, get_hosted_zone_id, get_record_ip_address, get_root_domain, https, https_get, launch_hook_server, launch_private_dns, launch_service_unit, launch_stack, lift, liftAll, lift_object, mustache, node_lift, parse, pause, prepare_docker_mount_template, prepare_ephemeral_drive_template, prepare_hook_server_template, prepare_launch_repository, promise, pull_cloud_template, read, resolve, set_aws_creds, set_hostname, templatize, validate_key_pair, where, write, _ref, _ref1, _ref2,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  https = require("https");

  resolve = require("path").resolve;

  _ref = require("fairmont"), read = _ref.read, write = _ref.write;

  parse = require("c50n").parse;

  where = require("underscore").where;

  _ref1 = require("when"), promise = _ref1.promise, lift = _ref1.lift;

  liftAll = require("when/node").liftAll;

  node_lift = (require("when/node")).lift;

  async = (require("when/generator")).lift;

  _ref2 = require("shelljs"), exec = _ref2.exec, error = _ref2.error;

  AWS = require("aws-sdk");

  mustache = require("mustache");

  build_error = function(message, details) {
    error = new Error(message);
    if (details != null) {
      error.details = details;
    }
    return error;
  };

  build_success = function(message, data, code) {
    return {
      message: message,
      status: "success",
      code: code != null ? code : void 0,
      details: data != null ? data : void 0
    };
  };

  execute = function(command) {
    exec(command);
    if (error() != null) {
      return build_error("ShellJS failed to execute shell command.", error());
    }
  };

  lift_object = function(object, method) {
    return node_lift(method.bind(object));
  };

  pause = function(duration) {
    return promise(function(resolve, reject) {
      var callback;
      callback = function() {
        return resolve();
      };
      return setTimeout(callback, duration);
    });
  };

  https_get = function(url) {
    return promise(function(resolve, reject) {
      return https.get(url).on("response", function(response) {
        return resolve(response);
      }).on("error", function(error) {
        return resolve(error);
      });
    });
  };

  get_body = function(response) {
    return promise(function(resolve, reject) {
      var data;
      data = "";
      return response.setEncoding("utf8").on("data", function(chunk) {
        return data = data + chunk;
      }).on("end", function() {
        return resolve(data);
      }).on("error", function(error) {
        return resolve(error);
      });
    });
  };

  get_discovery_url = async(function*() {
    return (yield get_body((yield https_get("https://discovery.etcd.io/new"))));
  });

  pull_cloud_template = async(function*(_arg) {
    var channel, response, template_object, template_store, template_url, virtualization;
    channel = _arg.channel, virtualization = _arg.virtualization;
    channel || (channel = "stable");
    virtualization || (virtualization = "pv");
    template_store = parse(read(resolve(__dirname, "templates.cson")));
    template_url = template_store[channel][virtualization];
    try {
      response = (yield https_get(template_url));
      template_object = JSON.parse((yield get_body(response)));
      return template_object;
    } catch (_error) {
      error = _error;
      return build_error("Unable to access AWS template stores belonging to CoreOS", error);
    }
  });

  add_unit = function(cloud_config, unit) {
    var content;
    cloud_config.push("    - name: " + unit.name + "\n");
    if (unit.runtime != null) {
      cloud_config.push("      runtime: " + unit.runtime + "\n");
    }
    if (unit.command != null) {
      cloud_config.push("      command: " + unit.command + "\n");
    }
    if (unit.enable != null) {
      cloud_config.push("      enable: " + unit.enable + "\n");
    }
    cloud_config.push("      content: |\n");
    content = read(resolve(__dirname, "services/" + unit.name));
    content = content.split("\n");
    while (content.length > 0) {
      cloud_config.push("        " + content[0] + "\n");
      content.shift();
    }
    return cloud_config;
  };

  templatize = function(relative_read_path, relative_write_path, data) {
    var hook_server_template, results_text;
    hook_server_template = read(resolve(__dirname, relative_read_path));
    results_text = mustache.render(hook_server_template.toString(), data);
    write(resolve(relative_write_path), results_text);
    return true;
  };

  prepare_ephemeral_drive_template = function(drive_path) {
    drive_path = drive_path || "/dev/xvdb";
    templatize("services/format-ephemeral.template", "src/services/format-ephemeral.service", {
      drive_path: drive_path
    });
    return true;
  };

  prepare_docker_mount_template = function(drive_path) {
    drive_path = drive_path || "/dev/xvdb";
    templatize("services/var-lib-docker.template", "src/services/var-lib-docker.mount", {
      drive_path: drive_path
    });
    return true;
  };

  build_template = async(function*(options) {
    var cloud_config, template_object, user_data, x, _i, _j, _len, _len1, _ref3, _ref4;
    try {
      template_object = (yield pull_cloud_template(options));
      user_data = template_object.Resources.CoreOSServerLaunchConfig.Properties.UserData;
      cloud_config = user_data["Fn::Base64"]["Fn::Join"][1];
      prepare_ephemeral_drive_template(options.ephemeral_drive);
      prepare_docker_mount_template(options.ephemeral_drive);
      if (options.formation_units !== []) {
        _ref3 = options.formation_units;
        for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
          x = _ref3[_i];
          cloud_config = add_unit(cloud_config, x);
        }
      }
      if (options.public_keys !== []) {
        cloud_config.push("ssh_authorized_keys: \n");
        _ref4 = options.public_keys;
        for (_j = 0, _len1 = _ref4.length; _j < _len1; _j++) {
          x = _ref4[_j];
          cloud_config.push("  - " + x + "\n");
        }
      }
      user_data["Fn::Base64"]["Fn::Join"][1] = cloud_config;
      template_object.Resources.CoreOSServerLaunchConfig.Properties.UserData = user_data;
      return JSON.stringify(template_object, null, "\t");
    } catch (_error) {
      error = _error;
      return build_error("Unable to build CloudFormation template.", error);
    }
  });

  set_aws_creds = function(creds) {
    return {
      accessKeyId: creds.id,
      secretAccessKey: creds.key,
      region: creds.region,
      sslEnabled: true
    };
  };

  validate_key_pair = async(function*(key_pair, creds) {
    var data, describe_key_pairs, ec2, err, key, names, _i, _len, _ref3;
    AWS.config = set_aws_creds(creds);
    ec2 = new AWS.EC2();
    describe_key_pairs = lift_object(ec2, ec2.describeKeyPairs);
    try {
      data = (yield describe_key_pairs({}));
      names = [];
      _ref3 = data.KeyPairs;
      for (_i = 0, _len = _ref3.length; _i < _len; _i++) {
        key = _ref3[_i];
        names.push(key.KeyName);
      }
      if (__indexOf.call(names, key_pair) < 0) {
        return build_error("This AWS account does not have a key pair named \"" + key_pair + "\".");
      }
      return true;
    } catch (_error) {
      err = _error;
      return build_error("Unable to validate SSH key.", err);
    }
  });

  launch_stack = async(function*(options, creds) {
    var cf, create_stack, data, err, params;
    try {
      params = {};
      params.StackName = options.stack_name;
      params.OnFailure = "DELETE";
      params.TemplateBody = (yield build_template(options));
      params.Parameters = [
        {
          "ParameterKey": "InstanceType",
          "ParameterValue": options.instance_type || "m3.medium"
        }, {
          "ParameterKey": "ClusterSize",
          "ParameterValue": options.cluster_size || "3"
        }, {
          "ParameterKey": "DiscoveryURL",
          "ParameterValue": (yield get_discovery_url())
        }, {
          "ParameterKey": "KeyPair",
          "ParameterValue": (yield validate_key_pair(options.key_pair, creds)) ? options.key_pair : void 0
        }
      ];
      AWS.config = set_aws_creds(creds);
      cf = new AWS.CloudFormation();
      create_stack = lift_object(cf, cf.createStack);
      data = (yield create_stack(params));
      return build_success("Cluster formation in progress.", data);
    } catch (_error) {
      err = _error;
      return build_error("Unable to access AWS CloudFormation", err);
    }
  });

  get_formation_status = async(function*(name, creds) {
    var cf, data, describe_events, err;
    AWS.config = set_aws_creds(creds);
    cf = new AWS.CloudFormation();
    describe_events = lift_object(cf, cf.describeStackEvents);
    try {
      data = (yield describe_events({
        StackName: name
      }));
      if (data.StackEvents[0].ResourceType === "AWS::CloudFormation::Stack" && data.StackEvents[0].ResourceStatus === "CREATE_COMPLETE") {
        return build_success("The cluster is confirmed to be online and ready.", data);
      } else if (data.StackEvents.ResourceStatus === "CREATE_FAILED") {
        return build_error("AWS CloudFormation returned status \"CREATE_FAILED\".", data);
      } else {
        return false;
      }
    } catch (_error) {
      err = _error;
      return build_error("Unable to access AWS CloudFormation.", err);
    }
  });

  detect_formation = async(function*(options, creds) {
    var status;
    try {
      while (true) {
        status = (yield get_formation_status(options.stack_name, creds));
        if (status) {
          return status;
        } else {
          (yield pause(5000));
        }
      }
    } catch (_error) {
      error = _error;
      return build_error("Unable to detect cluster formation.", error);
    }
  });

  get_cluster_ip_address = async(function*(options, creds) {
    var data, describe_instances, ec2, params;
    AWS.config = set_aws_creds(creds);
    ec2 = new AWS.EC2();
    describe_instances = lift_object(ec2, ec2.describeInstances);
    params = {
      Filters: [
        {
          Name: "tag:aws:cloudformation:stack-name",
          Values: [options.stack_name]
        }, {
          Name: "instance-state-code",
          Values: ["16"]
        }
      ]
    };
    try {
      data = (yield describe_instances(params));
      return data.Reservations[0].Instances[0].PublicIpAddress;
    } catch (_error) {
      error = _error;
      return build_error("Unable to access AWS EC2.", error);
    }
  });

  get_root_domain = function(url) {
    var domain, foo;
    try {
      if (url.indexOf("://") !== -1) {
        domain = url.split('/')[2];
      } else {
        domain = url.split('/')[0];
      }
      domain = domain.split(':')[0];
      foo = domain.split(".");
      if (foo[foo.length - 1] === "") {
        domain = foo[foo.length - 3] + "." + foo[foo.length - 2];
      } else {
        domain = foo[foo.length - 2] + "." + foo[foo.length - 1];
      }
      domain = domain + ".";
      return domain;
    } catch (_error) {
      error = _error;
      return build_error("There was an issue parsing the requested hostname.", error);
    }
  };

  get_hosted_zone_id = async(function*(hostname, creds) {
    var data, list_zones, r53, root_domain;
    try {
      root_domain = get_root_domain(hostname);
      AWS.config = set_aws_creds(creds);
      r53 = new AWS.Route53();
      list_zones = lift_object(r53, r53.listHostedZones);
      data = (yield list_zones({}));
      return where(data.HostedZones, {
        Name: root_domain
      })[0].Id;
    } catch (_error) {
      error = _error;
      return build_error("Unable to access AWS Route 53.", error);
    }
  });

  get_record_ip_address = async(function*(hostname, zone_id, creds) {
    var data, list_records, r53, record;
    try {
      AWS.config = set_aws_creds(creds);
      r53 = new AWS.Route53();
      list_records = lift_object(r53, r53.listResourceRecordSets);
      data = (yield list_records({
        HostedZoneId: zone_id
      }));
      record = where(data.ResourceRecordSets, {
        Name: hostname
      });
      return record[0].ResourceRecords[0].Value;
    } catch (_error) {
      error = _error;
      return build_error("Unable to access AWS Route 53.", error);
    }
  });

  set_hostname = async(function*(options, creds) {
    var change_record, data, old_ip_address, params, r53, zone_id;
    try {
      zone_id = (yield get_hosted_zone_id(options.hostname, creds));
      old_ip_address = (yield get_record_ip_address(options.hostname, zone_id, creds));
      params = {
        HostedZoneId: zone_id,
        ChangeBatch: {
          Changes: [
            {
              Action: "DELETE",
              ResourceRecordSet: {
                Name: options.hostname,
                Type: "A",
                TTL: 60,
                ResourceRecords: [
                  {
                    Value: old_ip_address
                  }
                ]
              }
            }, {
              Action: "CREATE",
              ResourceRecordSet: {
                Name: options.hostname,
                Type: "A",
                TTL: 60,
                ResourceRecords: [
                  {
                    Value: options.ip_address
                  }
                ]
              }
            }
          ]
        }
      };
      AWS.config = set_aws_creds(creds);
      r53 = new AWS.Route53();
      change_record = lift_object(r53, r53.changeResourceRecordSets);
      data = (yield change_record(params));
      return build_success("The domain \"" + options.hostname + "\" has been assigned to " + options.ip_address + ".", data);
    } catch (_error) {
      error = _error;
      return build_error("Unable to assign the cluster's IP address to the designated hostname.", error);
    }
  });

  launch_private_dns = async(function(domain, creds) {
    try {

    } catch (_error) {
      error = _error;
      return build_error("Unable to establish the cluster's private DNS.", error);
    }
  });

  prepare_launch_repository = async(function(config) {
    var command;
    try {
      command = ("ssh core@" + config.hostname + " << EOF\n") + "mkdir services\n" + "EOF";
      execute(command);
      return build_success("The Launch Repository is ready.");
    } catch (_error) {
      error = _error;
      return build_error("Unable to install the Launch Repository.", error);
    }
  });

  launch_service_unit = async(function(name, hostname) {
    var command;
    try {
      execute("scp " + __dirname + "/services/" + name + "  core@" + hostname + ":/home/core/services/.");
      command = ("ssh core@" + hostname + " << EOF\n") + ("fleetctl start services/" + name + "\n") + "EOF";
      return execute(command);
    } catch (_error) {
      error = _error;
      return build_error("Unable to launch service unit.", error);
    }
  });

  prepare_hook_server_template = function(_arg) {
    var after, drive_path, ssh_keys;
    ssh_keys = _arg.ssh_keys, after = _arg.after;
    drive_path = drive_path || "/dev/xvdb";
    templatize("services/format-ephemeral.template", "src/services/format-ephemeral.service", {
      drive_path: drive_path
    });
    return true;
  };

  launch_hook_server = async(function*(config) {
    try {
      return (yield launch_service_unit("hook-server.service", config.hostname));
    } catch (_error) {
      error = _error;
      return build_error("Unable to install hook-server into cluster.", error);
    }
  });

  customize_cluster = async(function*(options, creds) {
    var data;
    try {
      data = {};
      if (options.hostname != null) {
        data.set_hostname = (yield set_hostname(options, creds));
        (yield pause(65000));
      } else {
        options.hostname = options.ip_address;
      }
      return build_success("Cluster customizations are complete.", data);
    } catch (_error) {
      error = _error;
      return build_error("Unable to properly configure cluster.", error);
    }
  });

  destroy_cluster = async(function*(params, creds) {
    var cf, data, delete_stack, err;
    AWS.config = set_aws_creds(creds);
    cf = new AWS.CloudFormation();
    delete_stack = lift_object(cf, cf.deleteStack);
    try {
      data = (yield delete_stack(params));
      return data;
    } catch (_error) {
      err = _error;
      throw build_error("Unable to access AWS Cloudformation.", err);
    }
  });

  module.exports = {
    create: async(function*(options) {
      console.log("this is the pandacluster.js file")
      var credentials, data;
      credentials = options.aws;
      credentials.region = options.region || credentials.region;
      try {
        data = {};
        data.launch_stack = (yield launch_stack(options, credentials));
        data.detect_formation = (yield detect_formation(options, credentials));
        options.ip_address = (yield get_cluster_ip_address(options, credentials));
        data.customize_cluster = (yield customize_cluster(options, credentials));
        console.log(JSON.stringify(data, null, '\t'));
        return build_success("The requested cluster is online, configured, and ready.", data, 201);
      } catch (_error) {
        error = _error;
        console.log(JSON.stringify(error, null, '\t'));
        return build_error("Apologies. The requested cluster cannot be created.", error);
      }
    }),
    destroy: async(function*(options) {
      var credentials, data, params;
      credentials = options.aws;
      credentials.region = options.region || credentials.region;
      params = {};
      params.StackName = options.stack_name;
      try {
        data = {
          destroy_cluster: (yield destroy_cluster(params, credentials))
        };
        return build_success("The targeted cluster has been destroyed.  All related resources have been released.", data, 200);
      } catch (_error) {
        error = _error;
        return build_error("Apologies. The targeted cluster has not been destroyed.", error);
      }
    }),
    templatize: templatize
  };

}).call(this);
